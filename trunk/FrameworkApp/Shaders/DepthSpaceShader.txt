// HomoHack is the pixel centre offset. It defaults to 0.5, but can be overridden with 0.35
// when doing point sampling as that works better. For this case we are doing point sampling so pass 0.35
tF32    HomogeniseX (tINT Xc,tF32 HomoHack)
{
// Convert incoming screen x coordinate into -1 to +1 homogeneous space
return ((Xc-HomoHack)*(InvWidthF*2.0f))-1.0f;
}

tF32    HomogeniseY (tINT Yc,tF32 HomoHack)
{
// Convert incoming screen y coordinate into -1 to +1 homogeneous space
return 1.0f-((Yc-HomoHack)*(InvHeightF*2.0f));
}

tVOID    BuildFrustrumQuad (tVOID *Verts,RZView* View)
{
// This code gets coordinates in clipspace, accounting for DX9 pixel centre issue etc
// Width and Height are the screen dimensions
tF32    X1=HomogeniseX(0,0.35F);
tF32    X2=HomogeniseX(Width,0.35F);
tF32    Y1=HomogeniseY(0,0.35F);
tF32    Y2=HomogeniseY(Height,0.35F);
// Note that aspect ratio is cunningly being ignored
// Do some math to project the frustrum corners
tF32    FOV=View->GetCamera()->GetFOV();
tF32    Near=View->GetNearClip();
tF32    Far=View->GetFarClip();
tF32    NearH=2*RZMath::Tan(FOV)*Near;
tF32    NearW=NearH;
tF32    FarH=2*RZMath::Tan(FOV)*Far;
tF32    FarW=FarH;
tF32    NearX=NearW*0.5F;
tF32    NearY=NearH*0.5F;
tF32    FarX=FarW*0.5F;
tF32    FarY=FarH*0.5F;
// I'm using a custom vertex format for this that contains
// Position: FLOAT3
// UV: USHORT2
// Ray: FLOAT4
tDATAVERT*    Ptr=(tDATAVERT*)Verts;
// TL
Ptr[0].Pos.x=X1;
Ptr[0].Pos.y=Y1;
Ptr[0].Pos.z=0;
// I'm not including code for PackTexCoord. If you don't work
// this way with packed data, just use a float2 instead
Ptr[0].UV=RZCore::Core->VertexMgr->PackTexCoord(0,0);
Ptr[0].Vec.x=-FarX;
Ptr[0].Vec.y=FarY;
Ptr[0].Vec.z=Far;
Ptr[0].Vec.w=0;
// TR
Ptr[1].Pos.x=X2;
Ptr[1].Pos.y=Y1;
Ptr[1].Pos.z=0;
Ptr[1].UV=RZCore::Core->VertexMgr->PackTexCoord(1,0);
Ptr[1].Vec.x=FarX;
Ptr[1].Vec.y=FarY;
Ptr[1].Vec.z=Far;
Ptr[1].Vec.w=0;
// BL
Ptr[2].Pos.x=X1;
Ptr[2].Pos.y=Y2;
Ptr[2].Pos.z=0;
Ptr[2].UV=RZCore::Core->VertexMgr->PackTexCoord(0,1);
Ptr[2].Vec.x=-FarX;
Ptr[2].Vec.y=-FarY;
Ptr[2].Vec.z=Far;
Ptr[2].Vec.w=0;
// BR
Ptr[3].Pos.x=X2;
Ptr[3].Pos.y=Y2;
Ptr[3].Pos.z=0;
Ptr[3].UV=RZCore::Core->VertexMgr->PackTexCoord(1,1);
Ptr[3].Vec.x=FarX;
Ptr[3].Vec.y=-FarY;
Ptr[3].Vec.z=Far;
Ptr[3].Vec.w=0;

}